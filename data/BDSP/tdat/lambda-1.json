[
    {
        "type": "multi",
        "question": "What is the primary motivation for the Lambda Architecture?",
        "options": [
            "To handle massive quantities of data by combining batch and stream processing.",
            "To provide a robust system that is fault-tolerant against hardware failures and human errors.",
            "To replace relational databases with a single NoSQL solution.",
            "To serve data with low latency while maintaining accuracy."
        ],
        "answer": [
            0,
            1,
            3
        ],
        "explanation": "Lambda Architecture is designed to handle massive data, balance latency (speed) with throughput/accuracy (batch), and provide robustness (human fault tolerance via re-computation). Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "What are the three distinct layers of the Lambda Architecture?",
        "options": [
            "Batch Layer",
            "Speed Layer",
            "Serving Layer",
            "Storage Layer"
        ],
        "answer": [
            0,
            1,
            2
        ],
        "explanation": "The three main layers are the Batch Layer (master dataset), Speed Layer (real-time), and Serving Layer (querying). Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "What are the characteristics of the 'Master Dataset' in the Batch Layer?",
        "options": [
            "Immutable (data is never updated or deleted, only added).",
            "Append-only.",
            "Contains only the most recent 24 hours of data.",
            "Stores raw data as it arrived (truth)."
        ],
        "answer": [
            0,
            1,
            3
        ],
        "explanation": "The master dataset is an immutable, append-only set of raw data containing the entire history, acting as the single source of truth. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "What is the primary responsibility of the Batch Layer?",
        "options": [
            "To manage the master dataset.",
            "To pre-compute batch views (indexes) for the Serving Layer.",
            "To process data in real-time with millisecond latency.",
            "To fix errors in views by re-computing them from scratch."
        ],
        "answer": [
            0,
            1,
            3
        ],
        "explanation": "The Batch Layer manages the master data and computes comprehensive views. It allows fixing errors by re-computing views from the immutable master data. It is *not* for real-time. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "What is the primary responsibility of the Speed Layer?",
        "options": [
            "To compensate for the high latency of the Batch Layer.",
            "To process recent data that hasn't been processed by the Batch Layer yet.",
            "To store the master dataset permanently.",
            "To provide low-latency updates to the Serving Layer."
        ],
        "answer": [
            0,
            1,
            3
        ],
        "explanation": "The Speed Layer handles the 'gap'—recent data that the Batch Layer hasn't computed yet—providing low-latency views. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "What is the primary responsibility of the Serving Layer?",
        "options": [
            "To index and expose the views generated by the Batch and Speed layers.",
            "To perform complex data transformations and ETL.",
            "To respond to ad-hoc queries with low latency.",
            "To merge the results from Batch and Speed views during a query."
        ],
        "answer": [
            0,
            2,
            3
        ],
        "explanation": "The Serving Layer loads views and allows querying. It (or the client querying it) merges the Batch View and Speed View to get the complete result. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "How is a query resolved in the Lambda Architecture?",
        "options": [
            "Query = Function(Batch View)",
            "Query = Function(Speed View)",
            "Query = Function(Batch View) + Function(Speed View)",
            "Query = Function(Master Dataset) in real-time"
        ],
        "answer": [
            2
        ],
        "explanation": "A query is answered by merging the results from the Batch View (historical accuracy) and the Speed View (recent real-time data). Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "Which technologies are typically used in the Batch Layer?",
        "options": [
            "Apache Hadoop (HDFS + MapReduce)",
            "Apache Spark (Core)",
            "Apache Storm",
            "Apache Kafka"
        ],
        "answer": [
            0,
            1
        ],
        "explanation": "Hadoop and Spark Core are designed for high-throughput batch processing of large historical datasets. Storm/Kafka are for streaming. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "Which technologies are typically used in the Speed Layer?",
        "options": [
            "Apache Storm",
            "Apache Spark Streaming",
            "Apache Flink",
            "HDFS"
        ],
        "answer": [
            0,
            1,
            2
        ],
        "explanation": "Storm, Spark Streaming, and Flink are stream processing frameworks suitable for the low-latency Speed Layer. HDFS is storage. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "Which technologies are suitable for the Serving Layer?",
        "options": [
            "Apache HBase",
            "Apache Cassandra",
            "ElephantDB",
            "MongoDB"
        ],
        "answer": [
            0,
            1,
            2,
            3
        ],
        "explanation": "NoSQL databases that support fast random reads/writes (like HBase, Cassandra, MongoDB) are used to serve the views. ElephantDB is specifically for batch views. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "What is the main disadvantage/criticism of the Lambda Architecture?",
        "options": [
            "Complexity of maintaining two separate codebases (Batch and Speed).",
            "It cannot handle large datasets.",
            "High latency for all queries.",
            "Operational overhead of managing multiple distributed systems."
        ],
        "answer": [
            0,
            3
        ],
        "explanation": "The main criticism is the 'coding overhead'—you often have to implement the same logic twice (once for batch, once for stream) and manage complex infrastructure. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "What is the 'Kappa Architecture'?",
        "options": [
            "An architecture that removes the Batch Layer.",
            "An architecture that treats everything as a stream.",
            "An architecture that uses only a relational database.",
            "An evolution of Lambda that simplifies the codebase."
        ],
        "answer": [
            0,
            1,
            3
        ],
        "explanation": "Kappa Architecture simplifies Lambda by removing the Batch Layer and processing all data (historical and real-time) through a single stream processing engine. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "In Lambda Architecture, how is 'Human Fault Tolerance' achieved?",
        "options": [
            "Because the master dataset is immutable, data is never lost.",
            "If code has a bug, you can fix the code and re-compute the Batch Views from scratch.",
            "By using RAID hard drives.",
            "The Speed layer automatically fixes bugs in the Batch layer."
        ],
        "answer": [
            0,
            1
        ],
        "explanation": "Immutability allows you to delete corrupted views and re-run the batch job on the raw master data to correct errors (human fault tolerance). Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "How does the Batch Layer handle 'Scalability'?",
        "options": [
            "By using distributed file systems (HDFS) to store petabytes of data.",
            "By using parallel processing frameworks (MapReduce/Spark).",
            "By deleting old data.",
            "By vertical scaling (buying bigger servers)."
        ],
        "answer": [
            0,
            1
        ],
        "explanation": "The Batch Layer relies on horizontal scaling provided by distributed storage (HDFS) and compute (MapReduce/Spark) to handle growing data volumes. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "What happens to data in the Speed Layer once it is processed by the Batch Layer?",
        "options": [
            "It is discarded or no longer queried.",
            "It is merged into the Master Dataset.",
            "It is kept forever in the Speed Layer.",
            "The Serving Layer stops looking at the Speed View for that time range."
        ],
        "answer": [
            0,
            4
        ],
        "explanation": "Once the Batch Layer finishes a cycle (e.g., computes yesterday's data), the Speed Layer results for that period are redundant and can be discarded/ignored. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "What is 'Eventual Consistency' in the context of Lambda Architecture?",
        "options": [
            "The Batch View is always slightly out of date (high latency).",
            "The Speed View provides recent data but might be less accurate (approximate).",
            "The system eventually converges to a consistent state once the Batch Layer completes.",
            "Data is never consistent."
        ],
        "answer": [
            0,
            2
        ],
        "explanation": "Real-time results might be approximate. The system achieves consistency when the Batch Layer (the source of truth) eventually processes the data and updates the views. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "Which of the following describes the Batch View?",
        "options": [
            "It is a pre-computed function on the Master Dataset.",
            "It is read-optimized (indexed for fast queries).",
            "It is write-optimized.",
            "It is typically static (immutable) until the next batch cycle."
        ],
        "answer": [
            0,
            1,
            3
        ],
        "explanation": "Batch Views are the result of running a function on the master data. They are designed for fast reads and are replaced/updated in bulk, not incrementally updated in real-time. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "Why is 'Re-computation' important?",
        "options": [
            "It allows correcting data corruption caused by buggy algorithms.",
            "It allows computing new views (new metrics) on historical data.",
            "It speeds up real-time processing.",
            "It reduces storage costs."
        ],
        "answer": [
            0,
            1
        ],
        "explanation": "Re-computation on raw data enables fixing bugs (re-calculating correct numbers) and deriving new insights (new views) from the past. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "How does Apache Spark fit into the Lambda Architecture?",
        "options": [
            "Spark Core can be used for the Batch Layer.",
            "Spark Streaming can be used for the Speed Layer.",
            "Spark SQL can be used for ad-hoc analysis.",
            "Spark allows sharing code between Batch and Speed layers."
        ],
        "answer": [
            0,
            1,
            2,
            3
        ],
        "explanation": "Spark is unique because it provides a unified stack (Lambda in a box), allowing code reuse between batch and streaming components. Source: 9_lambda_data_processing_architecture.pdf (Slide 5)."
    },
    {
        "type": "multi",
        "question": "What is the role of Apache Kafka in Lambda Architecture?",
        "options": [
            "It serves as the ingestion buffer for incoming raw data.",
            "It feeds data to both the Batch Layer (e.g., via HDFS sink) and the Speed Layer.",
            "It acts as the Serving Layer database.",
            "It stores the Batch Views."
        ],
        "answer": [
            0,
            1
        ],
        "explanation": "Kafka typically sits at the entrance, retaining raw logs and feeding them to both HDFS (Batch) and Storm/Spark (Speed). Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "What is 'Complexity Isolation' in Lambda Architecture?",
        "options": [
            "The complexity of dealing with random writes and incremental updates is isolated in the Speed Layer.",
            "The Batch Layer is simple because it deals with immutable data (functional transformation).",
            "The Speed Layer is temporary, so its complexity is manageable (results are discarded).",
            "Users don't need to know about the layers."
        ],
        "answer": [
            0,
            1,
            2
        ],
        "explanation": "Batch processing is simpler (functional). The complex logic of handling concurrent updates/state is confined to the Speed Layer, whose errors are eventually corrected by the Batch Layer. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "Which databases are 'Batch Write' optimized (suitable for Batch View loading)?",
        "options": [
            "ElephantDB",
            "HBase (bulk load)",
            "MySQL (standard inserts)",
            "Oracle"
        ],
        "answer": [
            0,
            1
        ],
        "explanation": "Specialized stores like ElephantDB or HBase (bulk load) are designed to accept massive pre-computed datasets quickly, unlike standard RDBMS inserts. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "What does 'Immutable Data' imply for the architecture?",
        "options": [
            "No UPDATE or DELETE operations on the master dataset.",
            "Mistakes in data entry are handled by adding a new 'correction' record, not by modifying the old one.",
            "The database size grows indefinitely.",
            "Queries are slower."
        ],
        "answer": [
            0,
            1,
            2
        ],
        "explanation": "Immutability means append-only. To 'change' a value, you add a new record with a newer timestamp. This leads to ever-growing storage needs. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "What are the key differences between Batch and Speed layers?",
        "options": [
            "Batch Layer favors high throughput; Speed Layer favors low latency.",
            "Batch Layer provides exact results; Speed Layer provides approximate/speculative results.",
            "Batch Layer looks at all data; Speed Layer looks at recent data.",
            "Batch Layer uses RAM; Speed Layer uses Disk."
        ],
        "answer": [
            0,
            1,
            2
        ],
        "explanation": "The fundamental trade-off is Latency vs. Throughput/Completeness. Batch does 'everything, perfectly, slowly'. Speed does 'recent, roughly, quickly'. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "Why is the Serving Layer separate from the Batch Layer?",
        "options": [
            "Batch processing tools (like MapReduce) are not designed for low-latency random reads.",
            "Serving Layer databases are optimized for random access queries.",
            "To scale read traffic independently of write/compute traffic.",
            "Because they use different hardware."
        ],
        "answer": [
            0,
            1,
            2
        ],
        "explanation": "Hadoop/Spark are compute engines, not low-latency databases. The Serving layer (HBase, etc.) allows users to query the computed results instantly. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "What is the typical data flow in Lambda Architecture?",
        "options": [
            "Data -> Batch Layer -> Batch View -> Serving Layer.",
            "Data -> Speed Layer -> Speed View -> Serving Layer.",
            "Data -> Serving Layer -> Speed Layer.",
            "Query -> Serving Layer -> (Batch View + Speed View)."
        ],
        "answer": [
            0,
            1,
            3
        ],
        "explanation": "Data forks to both layers. Both layers push views to Serving. Queries merge views at Serving. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "Which of the following scenarios benefit from Lambda Architecture?",
        "options": [
            "A social media dashboard showing historical trends and current activity.",
            "A banking system requiring immediate fraud detection and monthly reports.",
            "An IoT monitoring system for real-time alerts and long-term analytics.",
            "A static personal blog."
        ],
        "answer": [
            0,
            1,
            2
        ],
        "explanation": "Systems requiring both historical depth (batch) and real-time responsiveness (speed) are ideal candidates. A static blog is too simple. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "How does Kappa Architecture differ from Lambda?",
        "options": [
            "It treats history as a stream (replaying the log).",
            "It uses a single code path (Stream Processing).",
            "It requires a very long retention period in the message queue (e.g., Kafka).",
            "It adds a third processing layer."
        ],
        "answer": [
            0,
            1,
            2
        ],
        "explanation": "Kappa says 'everything is a stream'. To recompute, you replay the Kafka log from the beginning through the stream engine. This removes the Batch Layer. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "What is a 'View' in this context?",
        "options": [
            "A derived dataset optimized for specific queries.",
            "A visual chart.",
            "An index structure (e.g., Key-Value map).",
            "A SQL view."
        ],
        "answer": [
            0,
            2
        ],
        "explanation": "A View is the output of the processing layers, typically structured (like a KV store) to answer specific questions efficiently. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "What are the challenges of the Speed Layer?",
        "options": [
            "Algorithms must be incremental.",
            "Handling out-of-order data.",
            "Approximating results due to memory constraints.",
            "Managing mutable state."
        ],
        "answer": [
            0,
            1,
            2,
            3
        ],
        "explanation": "Stream processing is hard: handling state, late data, and approximate algorithms (like HyperLogLog) is necessary for speed. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "Which CAP Theorem properties does Lambda Architecture typically aim for?",
        "options": [
            "Consistency (eventual) and Availability.",
            "Partition Tolerance.",
            "Immediate Strong Consistency.",
            "Availability over Consistency in the Speed Layer."
        ],
        "answer": [
            0,
            1,
            3
        ],
        "explanation": "Distributed systems must be P. Lambda usually chooses A (always answer queries) with Eventual Consistency (Batch corrects Speed). Speed layer sacrifices C for A. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "Why is 'Raw Data' storage important?",
        "options": [
            "It allows answering questions you haven't thought of yet (by computing new views).",
            "It serves as the ultimate backup.",
            "It allows auditing and debugging.",
            "It is required for the Speed Layer."
        ],
        "answer": [
            0,
            1,
            2
        ],
        "explanation": "Storing raw data (not just aggregates) provides flexibility to evolve the system and ask new questions of old data. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "What happens when code in the Batch Layer is updated?",
        "options": [
            "You can re-run the batch job on the entire Master Dataset.",
            "The Batch Views are completely regenerated.",
            "The Serving Layer is updated with the new views.",
            "The Speed Layer must be stopped."
        ],
        "answer": [
            0,
            1,
            2
        ],
        "explanation": "This is the 'Human Fault Tolerance' aspect. You deploy new code, re-compute the batch views, and swap them in. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "What role does HDFS play in the Batch Layer?",
        "options": [
            "Reliable, scalable storage for the Master Dataset.",
            "Supports massive parallel processing (data locality).",
            "Provides low-latency random access.",
            "Acts as the Speed Layer buffer."
        ],
        "answer": [
            0,
            1
        ],
        "explanation": "HDFS is the standard storage for the immutable master dataset, supporting MapReduce/Spark batch jobs. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "What is 'Incremental Batch Processing'?",
        "options": [
            "Running batch jobs more frequently (e.g., every 15 minutes) to reduce Speed Layer load.",
            "Only processing new data since the last batch.",
            "A hybrid between Batch and Speed.",
            "Deleting old batch views."
        ],
        "answer": [
            0,
            1,
            2
        ],
        "explanation": "To optimize, batch jobs can run incrementally (mini-batches) rather than re-computing everything every time, reducing the 'gap' the Speed Layer must fill. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "Which frameworks support the 'Unified' approach (Batch + Streaming in one API)?",
        "options": [
            "Apache Spark (Structured Streaming).",
            "Apache Flink.",
            "Apache Beam.",
            "Hadoop MapReduce."
        ],
        "answer": [
            0,
            1,
            2
        ],
        "explanation": "Spark, Flink, and Beam allow writing logic once and applying it to both batch and stream modes, addressing the code duplication issue of Lambda. Source: 9_lambda_data_processing_architecture.pdf (Slide 11)."
    },
    {
        "type": "multi",
        "question": "How does the Speed Layer handle 'State'?",
        "options": [
            "It keeps transient state in memory or a fast KV store.",
            "It uses techniques like 'updateStateByKey' in Spark.",
            "It writes state to HDFS.",
            "It does not maintain state."
        ],
        "answer": [
            0,
            1
        ],
        "explanation": "Speed layer needs state (e.g., current counts). It uses memory or fast DBs (Cassandra/Redis). HDFS is too slow. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "What is the relationship between 'Latency' and 'Throughput' in Lambda?",
        "options": [
            "Batch Layer = High Throughput, High Latency.",
            "Speed Layer = Low Throughput, Low Latency.",
            "Speed Layer = Moderate Throughput, Low Latency.",
            "Serving Layer = High Concurrency, Low Latency."
        ],
        "answer": [
            0,
            2,
            3
        ],
        "explanation": "Batch maximizes throughput (processing TBs). Speed minimizes latency. Serving maximizes concurrent read access. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "When might you chose Kappa over Lambda?",
        "options": [
            "When algorithms are identical for batch and stream.",
            "When you want to avoid maintaining two distributed systems (Hadoop + Storm).",
            "When history can be replayed from the log (Kafka) efficiently.",
            "When you need 100% pixel-perfect accuracy that only Batch can provide."
        ],
        "answer": [
            0,
            1,
            2
        ],
        "explanation": "Kappa is chosen for simplicity when the streaming engine is powerful enough to handle reprocessing history (replays), avoiding the dual-stack complexity. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "What is a 'Real-time View'?",
        "options": [
            "The output of the Speed Layer.",
            "It covers the time period since the last Batch View was computed.",
            "It is merged with the Batch View to answer queries.",
            "It is stored in HDFS."
        ],
        "answer": [
            0,
            1,
            2
        ],
        "explanation": "Real-time views represent the 'delta' or recent data not yet in the Batch View. They are stored in the Serving/Speed DB (e.g., Cassandra), not HDFS. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "Which of the following describes 'Vertical Partitioning' in Serving Layer?",
        "options": [
            "Storing different views in different databases.",
            "Splitting a table by columns.",
            "Optimizing for specific query types.",
            "Sharding data by key."
        ],
        "answer": [
            0,
            1
        ],
        "explanation": "Vertical partitioning (splitting by function/view) allows optimizing storage for specific query patterns. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "How does 'Data Re-processing' work in Kappa Architecture?",
        "options": [
            "Start a new instance of the streaming job.",
            "Point it to the beginning of the Kafka topic (retention permitting).",
            "Output to a new table.",
            "Switch the application to read from the new table once caught up."
        ],
        "answer": [
            0,
            1,
            2,
            3
        ],
        "explanation": "Kappa reprocessing involves replaying the stream from offset 0 into a new version of the view, then switching the serving layer to point to it. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "What is the 'Query Layer'?",
        "options": [
            "Another name for the Serving Layer.",
            "The client-side logic that merges Batch and Speed views.",
            "The SQL interface.",
            "The Hadoop NameNode."
        ],
        "answer": [
            0,
            1
        ],
        "explanation": "Often the Serving Layer and Query logic are tightly coupled. The application/client must know how to query both views and combine them. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "Which problems does the Batch Layer solve that the Speed Layer typically cannot?",
        "options": [
            "Global optimization over the entire dataset.",
            "Handling massive join operations across years of data.",
            "100% accurate results without approximation.",
            "Sub-second latency."
        ],
        "answer": [
            0,
            1,
            2
        ],
        "explanation": "Batch allows global, accurate computations on full history (e.g., training ML models on all data) which is hard in streaming. It fails at low latency. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "What does 'Append-Only' mean for data modeling?",
        "options": [
            "To update a user's address, you insert a new record with a new timestamp.",
            "You never execute SQL UPDATE statements.",
            "It simplifies replication and consistency.",
            "It consumes less storage."
        ],
        "answer": [
            0,
            1,
            2
        ],
        "explanation": "Append-only simplifies distributed systems (no locking/conflict resolution for updates). It consumes *more* storage, not less. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "Why is 'Random Read' performance critical for the Serving Layer?",
        "options": [
            "Because end-users/applications expect instant responses.",
            "Because views are typically queried by Key (e.g., UserID).",
            "Because HDFS does not support random reads efficiently.",
            "To support real-time dashboards."
        ],
        "answer": [
            0,
            1,
            2,
            3
        ],
        "explanation": "The Serving Layer exists specifically because HDFS (Batch) is slow. Random reads enable interactive applications. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "What is the role of 'Views' in terms of normalization?",
        "options": [
            "Views are typically denormalized.",
            "Views are pre-joined and pre-aggregated.",
            "Views follow 3rd Normal Form.",
            "Views are optimized for read speed, not write efficiency."
        ],
        "answer": [
            0,
            1,
            3
        ],
        "explanation": "Big Data views are denormalized (NoSQL style) to avoid expensive joins at query time. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "Which components handle 'Serialization' in this architecture?",
        "options": [
            "Thrift / Avro / Protocol Buffers are often used.",
            "Serialization is needed to move data between layers.",
            "The Serving Layer requires efficient serialization for storage.",
            "JSON is the only option."
        ],
        "answer": [
            0,
            1,
            2
        ],
        "explanation": "Efficient binary serialization (Avro/Thrift) is crucial for performance and schema evolution in Lambda. JSON is text-based and slow. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "How does Lambda Architecture handle 'Late Data'?",
        "options": [
            "The Speed Layer handles it temporarily.",
            "The Batch Layer eventually processes it and corrects the view.",
            "Late data is discarded.",
            "It causes the system to crash."
        ],
        "answer": [
            0,
            1
        ],
        "explanation": "Speed layer does its best. The ultimate handling is by the Batch Layer, which will include the late data in the next full re-computation, correcting any temporary drift. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    },
    {
        "type": "multi",
        "question": "What is 'Polyglot Persistence' in this context?",
        "options": [
            "Using different database technologies for different views/needs.",
            "Using HDFS for batch, HBase for random access, Redis for caching.",
            "Writing code in multiple languages.",
            "Storing data in multiple formats."
        ],
        "answer": [
            0,
            1
        ],
        "explanation": "Lambda encourages using the right tool for the job: HDFS for master data, various NoSQL DBs (HBase, Redis, Solr) for different Serving Layer views. Source: IT4931_lecture_notes.pdf (Chapter 8)."
    }
]